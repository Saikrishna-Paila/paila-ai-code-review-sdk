"""
Base Integration
================

Abstract base class for external integrations.
"""

from abc import ABC, abstractmethod
from typing import Optional, List, Dict, Any

from ..models import ReviewResult, Issue


class BaseIntegration(ABC):
    """
    Abstract base class for external service integrations.

    To create a new integration:

        class MyIntegration(BaseIntegration):
            name = "my_service"

            def post_review(self, result, **kwargs):
                # Post review to service
                pass

            def get_changed_files(self, **kwargs):
                # Get list of changed files
                return []
    """

    name: str = "base"

    def __init__(
        self,
        token: Optional[str] = None,
        base_url: Optional[str] = None,
    ):
        """
        Initialize the integration.

        Args:
            token: Authentication token
            base_url: Base URL for the service API
        """
        self.token = token
        self.base_url = base_url

    @abstractmethod
    def post_review(
        self,
        result: ReviewResult,
        **kwargs
    ) -> Dict[str, Any]:
        """
        Post review result to the service.

        Args:
            result: Review result to post
            **kwargs: Service-specific options

        Returns:
            Response data from the service
        """
        pass

    @abstractmethod
    def get_changed_files(self, **kwargs) -> List[str]:
        """
        Get list of changed files.

        Args:
            **kwargs: Service-specific options

        Returns:
            List of file paths
        """
        pass

    def format_comment(
        self,
        result: ReviewResult,
        include_details: bool = True
    ) -> str:
        """
        Format review result as a comment.

        Args:
            result: Review result
            include_details: Include detailed issue list

        Returns:
            Formatted comment string
        """
        lines = [
            "## ğŸ” Paila Code Review",
            "",
            f"**Score:** {result.score}/100 (Grade: **{result.grade}**)",
            f"**Issues Found:** {result.total_issues}",
            "",
        ]

        # Severity breakdown
        if result.issues_by_severity:
            lines.append("### Issues by Severity")
            lines.append("")
            lines.append("| Severity | Count |")
            lines.append("|----------|-------|")

            for sev in ["critical", "high", "medium", "low", "info"]:
                count = result.issues_by_severity.get(sev, 0)
                if count > 0:
                    lines.append(f"| {sev.title()} | {count} |")

            lines.append("")

        # Top issues
        if include_details:
            all_issues: List[Issue] = []
            for f in result.files:
                all_issues.extend(f.issues)

            # Sort by severity
            severity_order = {
                "critical": 0, "high": 1, "medium": 2, "low": 3, "info": 4
            }
            all_issues.sort(key=lambda i: severity_order.get(i.severity.value, 5))

            if all_issues:
                lines.append("### Top Issues")
                lines.append("")

                for issue in all_issues[:10]:
                    lines.append(
                        f"- **[{issue.severity.value.upper()}]** "
                        f"{issue.message} (`{issue.file}:{issue.line}`)"
                    )

                if len(all_issues) > 10:
                    lines.append(f"- ... and {len(all_issues) - 10} more")

                lines.append("")

        lines.append("---")
        lines.append("*Generated by [Paila SDK](https://github.com/saikrishnapaila/paila)*")

        return "\n".join(lines)

    def format_inline_comment(self, issue: Issue) -> str:
        """
        Format a single issue as an inline comment.

        Args:
            issue: Issue to format

        Returns:
            Formatted inline comment
        """
        lines = [
            f"**[{issue.severity.value.upper()}]** {issue.message}",
            "",
        ]

        if issue.code:
            lines.append("```python")
            lines.append(issue.code)
            lines.append("```")
            lines.append("")

        if issue.suggestion:
            lines.append(f"ğŸ’¡ **Suggestion:** {issue.suggestion}")

        if issue.rule:
            lines.append(f"ğŸ“‹ Rule: `{issue.rule}`")

        return "\n".join(lines)

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}()"
